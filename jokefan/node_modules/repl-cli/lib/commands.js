"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const _ = require("lodash");
const minimist = require("minimist");
const flattenObject = require("flat");
class CommandEvaluator {
    constructor(commands) {
        this.scopes = {};
        this.commands = commands || {};
    }
    isDefined(path) {
        return _.has(this.commands, path);
    }
    hasCommand(path) {
        return _.has(this.commands, path) && typeof _.get(this.commands, path) === 'function';
    }
    hasCommands(path) {
        return _.has(this.commands, path) && _.isPlainObject(_.get(this.commands, path));
    }
    registerCommand(path, callback) {
        if (_.has(this.commands, path))
            throw new Error(`command '${path}' already taken`);
        _.set(this.commands, path, callback);
    }
    unregisterCommand(path) {
        if (!_.has(this.commands, path))
            throw new Error(`command '${path}' not found`);
        _.unset(this.commands, path);
    }
    addCommand(path, callback, scopeName) {
        if (scopeName !== undefined) {
            if (this.scopes[scopeName] === undefined)
                this.scopes[scopeName] = { commands: {}, enabled: true };
            const scope = this.scopes[scopeName];
            if (_.has(scope.commands, path))
                throw new Error(`command '${path}' already taken`);
            _.set(scope.commands, path, callback);
        }
        if (scopeName === undefined || this.scopes[scopeName].enabled)
            this.registerCommand(path, callback);
    }
    removeCommand(path, scopeName) {
        if (scopeName !== undefined && this.scopes[scopeName] !== undefined) {
            const scope = this.scopes[scopeName];
            if (!_.has(scope.commands, path))
                throw new Error(`command '${path}' not found`);
            _.unset(this.scopes[scopeName].commands, path);
        }
        if (scopeName === undefined || this.scopes[scopeName] && this.scopes[scopeName].enabled)
            this.unregisterCommand(path);
    }
    addCommands(commands, scope) {
        _.forEach(flattenObject(commands), (callback, path) => {
            this.addCommand(path, callback, scope);
        });
    }
    enableScope(name) {
        const scope = this.scopes[name];
        if (scope === undefined) {
            this.scopes[name] = { commands: {}, enabled: true };
            return;
        }
        if (scope.enabled)
            return;
        _.forEach(flattenObject(scope.commands), (callback, path) => {
            this.registerCommand(path, callback);
        });
        scope.enabled = true;
    }
    disableScope(name) {
        const scope = this.scopes[name];
        if (scope === undefined) {
            this.scopes[name] = { commands: {}, enabled: false };
            return;
        }
        if (!scope.enabled)
            return;
        _.forEach(flattenObject(scope.commands), (callback, path) => {
            this.unregisterCommand(path, callback, name);
        });
        scope.enabled = false;
    }
    printNodeHelp(node) {
        console.log('Available commands:');
        for (const key of Object.keys(node))
            console.log(` - ${key}`);
    }
    printHelp(path) {
        if (!_.has(this.commands, path))
            throw new Error(`command '${path}' does not exist`);
        const node = _.get(this.commands, path);
        if (!_.isPlainObject(node))
            throw new Error(`no help avaialble about command`);
        this.printNodeHelp(_.get(this.commands, path));
    }
    evaluate(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const argv = minimist(input.split(' '));
            let node = this.commands;
            while (typeof node !== 'function') {
                if (node === undefined || Object.keys(node).length === 0)
                    throw new Error(`command not found`);
                if (argv._.length === 0) {
                    this.printNodeHelp(node);
                    return input;
                }
                node = node[argv._[0]];
                argv._.shift();
            }
            yield node(argv);
            return input;
        });
    }
}
exports.CommandEvaluator = CommandEvaluator;
